/*
Created by BluePyOpt(1.6.56) at 2019-04-04 11:17:36.965340
*/
{load_file("stdrun.hoc")}
{load_file("import3d.hoc")}
/*
 * Check that global parameters are the same as with the optimization
 */
proc check_parameter(/* name, expected_value, value */){
  strdef error
  if($2 != $3){
    sprint(error, "Parameter %s has different value %f != %f", $s1, $2, $3)
    execerror(error)
  }
}
proc check_simulator() {
  check_parameter("celsius", 34, celsius)
  check_parameter("v_init", -70, v_init)
}



begintemplate MOBmi_MC_bAC


public init, morphology, geom_nseg_fixed, geom_nsec, getCell, getCCell, setCCell, gid, getCell
public channel_seed, channel_seed_set
public connect2target, clear, ASCIIrpt
public soma, dend, apic, axon, myelin, getThreshold
create soma[1], dend[1], apic[1], axon[1], myelin[1]
public nSecAll, nSecSoma, nSecApical, nSecBasal, nSecMyelinated, nSecAxonalOrig, nSecAxonal
public CellRef, synHelperList, synlist
objref this, CellRef, segCounts, ASCIIrpt, synHelperList, synlist

public all, somatic, apical, axonal, basal, myelinated, APC
objref all, somatic, apical, axonal, basal, myelinated, APC


obfunc getCell(){
        return this
}

obfunc getCCell(){
	return CellRef
}
proc setCCell(){
       CellRef = $o1
}

//-----------------------------------------------------------------------------------------------

/*!
 * When clearing the model, the circular reference between Cells and CCells must be broken so the
 * entity watching reference counts can work.
 */
proc clear() { localobj nil
    CellRef = nil
}


/*!
 * @param $o1 NetCon source (can be nil)
 * @param $o2 Variable where generated NetCon will be placed
 */
proc connect2target() { //$o1 target point process, $o2 returned NetCon
  soma $o2 = new NetCon(&v(1), $o1)
  $o2.threshold = -30
}


proc init(/* args: morphology_dir, morphology_name */) {
  all = new SectionList()
  apical = new SectionList()
  axonal = new SectionList()
  basal = new SectionList()
  somatic = new SectionList()
  myelinated = new SectionList()

  synHelperList = new List()                                                     
  synlist = new List()     

  //For compatibility with BBP CCells
  CellRef = this

  forall delete_section()

  gid = $1

  if(numarg() >= 3) {
    load_morphology($s2, $s3)
  } else {
    load_morphology($s2, "mpg141017_a1-2_idC.asc")
  }

  geom_nseg()
  indexSections()
  insertChannel()
  biophys()

  // Initialize channel_seed_set to avoid accidents
  channel_seed_set = 0
  // Initialize random number generators
  re_init_rng()
}


proc indexSections() { local index
    index = 0
    forsec all {
        v(0.0001) = index
        index = index +1
    }
}


proc biophys() {local tau, cap
  tau = 20180
  cap = 1
  
  forsec CellRef.all {
    cm = cap
    ena = 40
    ek = -80
  }
  
  forsec CellRef.apical {
  }
  
  forsec CellRef.axonal {
  }
  
  forsec CellRef.basal {
  }
  
  forsec CellRef.somatic {
  }
  
  forsec CellRef.myelinated {
    gbar_kamt=0
    gbar_nax=0
    gbar_kdrmt=0
    g_pas=1/(tau/cap/3*10/3)
    cm=cap/100
  }
}


func sec_count(/* SectionList */) { local nSec
  nSec = 0
  forsec $o1 {
      nSec += 1
  }
  return nSec
}


proc geom_nseg() {
  this.geom_nsec() //To count all sections
  //TODO: geom_nseg_fixed depends on segCounts which is calculated by
  //  geom_nsec.  Can this be collapsed?
  this.geom_nseg_fixed(40)
  this.geom_nsec() //To count all sections
}

/*
 * Iterate over the section and compute how many segments should be allocate to
 * each.
 */
proc geom_nseg_fixed(/* chunkSize */) { local secIndex, chunkSize
  chunkSize = $1
  soma area(.5) // make sure diam reflects 3d points
  secIndex = 0
  forsec all {
    nseg = 1 + 2*int(L/chunkSize)
    segCounts.x[secIndex] = nseg
    secIndex += 1
  }
}

/*
 * Count up the number of sections
 */
proc geom_nsec() { local nSec
  nSecAll = sec_count(all)
  nSecSoma = sec_count(somatic)
  nSecApical = sec_count(apical)
  nSecBasal = sec_count(basal)
  nSecMyelinated = sec_count(myelinated)
  nSecAxonalOrig = nSecAxonal = sec_count(axonal)

  segCounts = new Vector()
  segCounts.resize(nSecAll)
  nSec = 0
  forsec all {
    segCounts.x[nSec] = nseg
    nSec += 1
  }
}


proc insertChannel() {local tau, cap, Vrest
  Vrest = -55
    tau = 20180
    cap = 1
                
    sh = 5
    
  forsec this.all {
    insert kamt gbar_kamt=0.004
    insert nax gbar_nax=0.04 sh_nax=15-sh
    insert kdrmt gbar_kdrmt=0.001
    insert pas g_pas=1/(tau/cap) Ra=150 cm=cap e_pas=Vrest
  }
  forsec this.apical {
  }
  forsec this.axonal {
  }
  forsec this.basal {
  }
  forsec this.somatic {
  }
  forsec this.myelinated {
  }
}


proc load_morphology(/* morphology_dir, morphology_name */) {localobj morph, import, sf, extension
  strdef morph_path
  sprint(morph_path, "%s/%s", $s1, $s2)

  sf = new StringFunctions()
  extension = new String()

  sscanf(morph_path, "%s", extension.s)
  sf.right(extension.s, sf.len(extension.s)-4)

  if(strcmp(extension.s, ".ASC") == 0 ){
    extension.s = ".asc"
    sf.left(morph_path, sf.len(morph_path)-3)
    sprint(morph_path,"%s%s",morph_path,"asc")
    print "USING LOWERCASE EXTENSION", morph_path
  }


  if( strcmp(extension.s, ".asc") == 0 ) {
    morph = new Import3d_Neurolucida3()
  } else if( strcmp(extension.s, ".swc" ) == 0) {
    morph = new Import3d_SWC_read()
  } else {
    printf(extension.s)
    printf("Unsupported file format: Morphology file has to end with .asc or .swc" )
    quit()
  }

  morph.quiet = 1
  morph.input(morph_path)

  import = new Import3d_GUI(morph, 0)
  import.instantiate(this)
}


proc re_init_rng() {localobj sf
    strdef full_str, name

    sf = new StringFunctions()

    if(numarg() == 1) {
        // We received a third seed
        channel_seed = $1
        channel_seed_set = 1
    } else {
        channel_seed_set = 0
    }
  }

endtemplate MOBmi_MC_bAC
